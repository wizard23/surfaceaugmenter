<html>
<head>
<title>SurfaceAugmenter</title>
<style> </style>
<script type="text/javascript" src="libs/NumJS/NumJS.js"></script>
<script type="text/javascript">NumJS.loader_html("libs/NumJS/")</script>
<script type="text/javascript" src="src/image.js"></script>
<script type="text/javascript" src="src/helpers.js"></script>
<script type="text/javascript" src="src/lines.js"></script>
<script type="text/javascript">

var img;
var imgWidth, imgHeight;

var imgScale = 1.0;
var points = [];
var pixels, bwPixels, maskPixels;

var maskInitBlack = 50;
var maskLine = 200;
var maskOutBlack = 100;

function setup()
{
	changeMode('advanced');

	document.getElementById('imageFile').addEventListener('change', handleImageSelect, false);
	document.getElementById('canvas').addEventListener('click', handleCanvasClick, false);

	// enable dnd on canvas to load images
	var holder = document.getElementById('canvas');
	holder.ondragover = function () { this.className = 'hover'; return false; };
	holder.ondragend = function () { this.className = ''; return false; };
	holder.ondrop = function (e) {
		this.className = '';  // what for?
		e.preventDefault();
		var file = e.dataTransfer.files[0];
		asyncLoadImageFromFile(file);
	};


	asyncLoadImageFromURL("test2.jpg");
}

function handleImageSelect(evt) {
	pixels = undefined;
	var files = evt.target.files; // FileList object
	var file = files[0];
	asyncLoadImageFromFile(file);
}

function handleCanvasClick(evt) {
	var canvas = document.getElementById('canvas');
	var context = canvas.getContext('2d');

	clearDump();
	
	if (!pixels) {
		pixels = context.getImageData(0,0, canvas.width, canvas.height);
		//pixels2 = context.getImageData(0,0, canvas.width, canvas.height);
		bwPixels = RGBA2A(pixels, context);
		bwPixelsSobolev = createImageDataA(canvas.width, canvas.height);
		applyKernelAlphaOnPixels(bwPixels, dxx, dyy, bwPixelsSobolev);
		bwPixelsSobolevClipped = createImageDataA(canvas.width, canvas.height);
		maskPixels = createImageDataA(canvas.width, canvas.height);
		APixelsFill(maskPixels, 0);
	}

	var coords = canvas.relMouseCoords(evt);
	var x = coords.x/imgScale;
	var y = coords.y/imgScale;

	if (document.getElementById("radioSearchTypeManual").checked)
	{
		if (x >= 0 && x < imgWidth && y >= 0 && y < imgHeight)
			points.push({x:x, y:y});

		context.beginPath();
		context.arc(x, y, 3, 0, Math.PI*2, true); 
		context.closePath();
		context.fill();
	
		if (points.length == 4)
		{
			doCorrection(pixels, points, context, null);
			points = [];
		}
	}
	else {
		x = Math.round(x);
		y = Math.round(y);

		var whiteSum = 255;
		var whiteVarsum = 0;
		var whiteN = 1;
		var blackSum = 0;
		var blackVarsum = 0;
		var blackN = 1;


		var br = 0.0;
		fill4(x, y, function(x, y, state) {
			if (x >= 0 && x < imgWidth && y >= 0 && y < imgHeight)	{
				var whiteAvg = whiteSum/whiteN;
				var blackAvg = blackSum/blackN;
				var whiteVar = whiteVarsum/whiteN;
				var blackVar = blackVarsum/blackN;

				var idx = x+imgWidth*y;
				var idx4 = 4*idx;
				var mask = maskPixels.data[idx];
				
				if (mask == maskInitBlack || mask == maskLine || mask == maskOutBlack) {
					return false;
				}
				var val = bwPixelsSobolev.data[idx];

				br += 0.03;
				//pixels.data[idx4] = br;
				//pixels.data[idx4+1] = br-255;
				//pixels.data[idx4+2] = br-512;

				if (state == maskInitBlack)
				{
					if (val > (0.5*blackAvg+0.5*whiteAvg)) {
						//blackSum += val; blackVarsum += Math.abs(val-blackAvg); blackN++;
						whiteSum += val; whiteVarsum += Math.abs(val-whiteAvg); whiteN++;

						maskPixels.data[idx] = maskLine;
						return maskLine;
					}

					blackSum += val; blackVarsum += Math.abs(val-blackAvg); blackN++;
					//whiteSum += val; whiteVarsum += Math.abs(val-whiteAvg); whiteN++;
					maskPixels.data[idx] = maskInitBlack;

					return maskInitBlack;
				}
				else if (state == maskLine)
				{
					if (val < (0.7*blackAvg+0.3*whiteAvg)) {

						maskPixels.data[idx] = maskOutBlack;
						return maskOutBlack;
					}
					//blackSum += val; blackVarsum += Math.abs(val-blackAvg); blackN++;
					whiteSum += val; whiteVarsum += Math.abs(val-whiteAvg); whiteN++;

					maskPixels.data[idx] = maskLine;

					return maskLine;
				}
			}
			return false;
		}, maskInitBlack);


		applyMaskAlphaOnPixels(bwPixelsSobolev, maskPixels, bwPixelsSobolevClipped)

		var bestGroup = findLineCandidates(pixels, maskPixels, bwPixelsSobolevClipped);
		for (var i = 0; i < bestGroup.length; i++) {
			improveLine(bestGroup[i], bwPixelsSobolevClipped, 4, 0.05);
		}
		
		var pointsIn = [];
		for (var i = 0; i < bestGroup.length; i++) {
			pointsIn.push(intersectLines(bestGroup[i], bestGroup[(i+1)%bestGroup.length]));
		}

		
		doCorrection(pixels, pointsIn, context, bestGroup);
	}
}

function doCorrection(pixels, pointsIn, context, bestGroup) {
		if (bestGroup == null) {
			var bestGroup = [];
			for (var i = 0; i < pointsIn.length; i++) {		
				bestGroup.push({p1:pointsIn[i], p2:pointsIn[(i+1)%4]});
			}
		}
		
		// draw outher lines in pixels
		for (var i = 0; i < bestGroup.length; i++) {		
			drawLine2(bestGroup[i].p1, bestGroup[i].p2, pixels, 0, 255, 0);
		}

		drawLine2(pointsIn[0], pointsIn[2], pixels, 0, 0, 255);
		drawLine2(pointsIn[1], pointsIn[3], pixels, 0, 0, 255);

		var pixelsIn = pixels;

		var minD = -1, minIdx = -1;
		for (var i = 0; i < 4; i++) {
			var d = distancePoints({x:0,y:0}, pointsIn[i]);
		
			if (minIdx < 0 || d < minD) {
				minD = d;
				minIdx = i;
			}
		}
		//minIdx;
		var newPoints = [];
		for (var i = 0; i < 4; i++) {
			newPoints.push(pointsIn[(i+minIdx)%4]);
		}
		pointsIn = newPoints;
		

		var dpi = getDpi();
		var scale = dpi*0.0393700788; // 1mm = 0.0393700787 inch
		var markerWidth = parseFloat(document.getElementById("markerWidth").value);
		var markerHeight = parseFloat(document.getElementById("markerHeight").value);
		var outW = markerWidth*scale, outH = markerHeight*scale; // size of my testpattern 170x250mm
		var inputW = distancePoints(pointsIn[0], pointsIn[1]);
		var inputH = distancePoints(pointsIn[1], pointsIn[2])
		if ((inputW > inputH) != (outW > outH)) {
			var t = outW;
			outW = outH;
			outH = t;
		}
		var pointsOut = [{x:0, y:0}, {x:outW-1, y:0}, {x:outW-1, y:outH-1}, {x:0, y:outH-1}];
		//var pointsOut = [{x:0, y:0}, {x:outW, y:0}, {x:outW, y:outH}, {x:0, y:outH}];
		var params = calcParameters(pointsIn, pointsOut);
		//var params = calcParameters(pointsOut, pointsIn);

		var corners = [{x:0,y:0}, {x:pixelsIn.width-1, y:0}, {x:pixelsIn.width-1, y:pixelsIn.height-1}, {x:0, y:pixelsIn.height-1}];
		//var corners = [{x:0,y:0}, {x:pixelsIn.width, y:0}, {x:pixelsIn.width, y:pixelsIn.height}, {x:0, y:pixelsIn.height}];
		var minX = 100000, minY = 100000, maxX =-100000, maxY = -100000;
		for (var i = 0; i < 4; i++) {
			var cornerT = fwdMapXY(params, corners[i]);
			//var cornerT = invMapXY(params, corners[i]);
			//alert(cornerT.x + " " + cornerT.y);
			if (cornerT.x < minX) minX = cornerT.x;
			if (cornerT.x > maxX) maxX = cornerT.x;
			if (cornerT.y < minY) minY = cornerT.y;
			if (cornerT.y > maxY) maxY = cornerT.y;
		}

		if (document.getElementById("optionOutputNearest").checked) {
			var pixelsOut = context.createImageData(Math.ceil(maxX-minX), Math.ceil(maxY-minY));

			var idxOut = 0;
			for (var yOut = 0; yOut < pixelsOut.height; yOut++) {
				for (var xOut = 0; xOut < pixelsOut.width; xOut++) {
					var pointIn = invMapXY(params, {x:xOut+minX, y:yOut+minY})
					var xIn = Math.round(pointIn.x);
					var yIn = Math.round(pointIn.y);
					if (xIn >= 0 && yIn >= 0 && xIn < pixelsIn.width && yIn < pixelsIn.height) {
						var idxIn = 4*(yIn*pixelsIn.width+xIn);
			
						pixelsOut.data[idxOut] = pixelsIn.data[idxIn+0];
						pixelsOut.data[idxOut+1] = pixelsIn.data[idxIn+1];
						pixelsOut.data[idxOut+2] = pixelsIn.data[idxIn+2];
						pixelsOut.data[idxOut+3] = pixelsIn.data[idxIn+3];
					}
					idxOut += 4;
				}
			}
			dumpImageData(pixelsOut, "Perspective corrected image (Filter: None, Nearest Neighbour)");
		}		
		if (document.getElementById("optionOutputBilinear").checked) {
			var pixelsOut = context.createImageData(Math.ceil(maxX-minX), Math.ceil(maxY-minY));

			var idxOut = 0;
			for (var yOut = 0; yOut < pixelsOut.height; yOut++) {
				for (var xOut = 0; xOut < pixelsOut.width; xOut++) {
					var pointIn = invMapXY(params, {x:xOut+minX, y:yOut+minY})
					var xNextIdx, xNextScale, yNextIdx, yNextScale, xyNextIdx, xyNextScale;
				
					var xIn = Math.round(pointIn.x);
					var yIn = Math.round(pointIn.y);
				
					var idxIn = 4*(yIn*pixelsIn.width+xIn);
					if (xIn > pointIn.x) {
						xNextIdx = idxIn-4;
						xNextScale = xIn - pointIn.x;
					}
					else {
						xNextIdx = idxIn+4;
						xNextScale = pointIn.x - xIn;	
					}

					if (yIn > pointIn.y) {
						yNextIdx = idxIn-4*pixelsIn.width;
						yNextScale = yIn - pointIn.y;
						xyNextIdx = xNextIdx-4*pixelsIn.width;
					}
					else {
						yNextIdx = idxIn+4*pixelsIn.width;
						yNextScale = pointIn.y - yIn;
						xyNextIdx = xNextIdx+4*pixelsIn.width;
					}
				
					if (xIn >= 0 && yIn >= 0 && xIn < pixelsIn.width && yIn < pixelsIn.height) {
						var idxOut = 4*(yOut*pixelsOut.width+xOut);

						for (var i = 0; i < 3; i++) {
							pixelsOut.data[idxOut+i] = (1-yNextScale) * ((1 - xNextScale) * pixelsIn.data[idxIn+i] + 
							(xNextScale) * pixelsIn.data[xNextIdx+i]) + 
							(yNextScale) * ((1 - xNextScale) * pixelsIn.data[yNextIdx+i] + 
							(xNextScale) * pixelsIn.data[xyNextIdx+i]);
						}	
						pixelsOut.data[idxOut+3] = 255;				
					}
					idxOut += 4;
				}
			}
			dumpImageData(pixelsOut, "Perspective corrected image (Filter: Bilinear)");	
		}
		

		context.putImageData(pixels, 0,0);
	
		if (document.getElementById("optionShowSobel").checked) 
		{
			var grayPixels = A2RGBA(bwPixelsSobolev, context);
			dumpImageData(grayPixels, "magnitude of the sobel gradient");
		}
		if (document.getElementById("optionShowMask").checked) {
			var grayPixels = A2RGBA(maskPixels, context);
			dumpImageData(grayPixels, "the mask used for clipping the gradient for the line search");
		}
		if (document.getElementById("optionShowClippedSobel").checked) 
		{
			var grayPixels = A2RGBA(bwPixelsSobolevClipped, context);
			dumpImageData(grayPixels, "clipped magnitude of the sobel gradient");
		}
		if (document.getElementById("optionShowClippedSobelLines").checked) 
		{
			var grayPixels = A2RGBA(bwPixelsSobolevClipped, context);
			if (bestGroup != null) {
			for (var i = 0; i < bestGroup.length; i++) {		
				drawLine2(bestGroup[i].p1, bestGroup[i].p2, grayPixels, 255, 0, 0);
			}
			}
			dumpImageData(grayPixels, "clipped magnitude of the gradient overlayed with the vectorized lines (this is used for the search so the vectorized lines should be very well aligned with the pixels");
		}
}

  
function drawImage(img) {
	var canvas = document.getElementById('canvas');
	
	canvas.width = img.width;
	canvas.height = img.height;
	imgWidth = img.width;
	imgHeight = img.height;
	
	var context = canvas.getContext('2d');
	context.drawImage(img, 0, 0, img.width, img.height);
	
	
} 

function scaleImage(scale)
{
	imgScale *= scale;
	var canvas = document.getElementById('canvas');
	canvas.style.width = "" + (imgWidth*imgScale) +"px";
	canvas.style.height = "" + (imgHeight*imgScale) +"px";
	// 		
	//canvas.height = imgHeight;
}

var hist = {};
function handleTestClick()
{
	var canvas = document.getElementById('canvas');
	var context = canvas.getContext('2d');

	//var pixels = context.getImageData(110,110,120,120);
	var pixels = context.getImageData(0,0, canvas.width, canvas.height);

	var bwPixels = RGBA2A(pixels, context);
	var bwPixelsSobolev = RGBA2A(pixels, context);

	

	var x, y;

	applyKernelAlphaOnPixels(bwPixels, dxx, dyy, bwPixelsSobolev)

	var grayPixels = A2RGBA(bwPixelsSobolev, context);
	context.putImageData(grayPixels, 0,0);


	return;

	Pixastic.process(document.getElementById("canvas"), "histogram", {
		average : false, paint:true,color:"rgba(255,255,255,0.5)",returnValue:hist
	});
	document.getElementById('debugText').value = hist.values;
}


var allowedModes = ['auto', 'advanced', 'lab', 'about'];
var currentMode;

function changeMode(mode) {
	for (var i = 0; i < allowedModes.length; i++) {
		var m = allowedModes[i];
		var id = m + "Controlls";
		if (m == mode) {
			//document.getElementById(id).style.visibility = "visible";
			document.getElementById(id).style.display = "block";
		}
		else {
			//document.getElementById(id).style.visibility = "hidden";
			document.getElementById(id).style.display = "none";
		}
	}
	currentMode = mode;
}

function clearDump() {
	removeAllChildrenFromNode(document.getElementById("dump"));
}

function dumpImageData(pixels, text) {

	var c = document.createElement('canvas');
	c.width = pixels.width;
	c.height = pixels.height;

	var div = document.createElement('div');
	div.innerText = text;
	document.getElementById("dump").appendChild(div);
	document.getElementById("dump").appendChild(c);

	var context = c.getContext('2d');	
	context.putImageData(pixels, 0,0);	
}

function getDpi() {
	if (currentMode == "auto")
		return parseFloat(document.getElementById('outputDpiAuto').value);
	if (currentMode == "advanced")
		return parseFloat(document.getElementById('outputDpiAdvanced').value);
	return 5; // defualt value for other modes (something small is good)
}

</script>

					
</head>
<body onload="setup()">
What do you want to do today? 
<a href="javascript:changeMode('auto');">Auto Perspective Correction</a> |
<a href="javascript:changeMode('advanced');">Advandced Perspective Correction</a> |
<a href="javascript:changeMode('lab');">Image Lab (Debug)</a> 
<a href="javascript:changeMode('about');">About</a> 
<br/><br/>
<form name="controls" action="">
<div id="autoControlls">
DPI of output image: <input type="text" id="outputDpiAuto" value="25" /><br/>
Click inside the inner white area of the marker to start the perspective correction.
</div>

<div id="advancedControlls">
DPI of output image: <input type="text" id="outputDpiAdvanced" value="25" /><br/>
Inner Width of Marker in mm: <input type="text" id="markerWidth" value="170" /><br/>
Inner Height of Marker in mm: <input type="text" id="markerHeight" value="250" /><br/>

<fieldset>
  <legend>How should the marker be found?</legend>
	<input id="radioSearchTypeManual" type="radio" name="searchType" value="manual">Manually click onto the 4 corners in clockwise order to start the perspective correction<br>
	<input id="radioSearchTypeClickCenter" type="radio" name="searchType" value="click" checked="true">Click inside the inner white area of the marker to start the perspective correction<br>
	<input id="radioSearchTypeAuto" type="radio" name="searchType" value="auto">NOT IMPLEMENTED: Automatic marker detection: Click anywhere in the image to start the perspective correction<br>
</fieldset>

<fieldset>
  <legend>How should the perspective correction be done? (Multiple output paths can be selected for comparison)</legend>
  <input id="optionOutputNearest" type="checkbox">Javascript/Canvas using No Filter/Nearest Neighbour (slow for large images)<br/>
  <input id="optionOutputBilinear" type="checkbox" checked="true">Javascript/Canvas using Bilinear Interpolation (slow for large images)<br/>
  <input id="optionOutputImageMagick" type="checkbox" checked="true">ImageMagick command line (recommended for larger DPI)<br>
</fieldset>

<fieldset>
  <legend>How does it work? Show me the guts!</legend>
  <input id="optionShowSobel" type="checkbox" checked="true"> Show Sobel Gradient Image<br/>
  <input id="optionShowMask" type="checkbox" checked="true"> Show Mask Image used for clipping<br/>
  <input id="optionShowClippedSobel" type="checkbox" checked="true"> Show Clipped Gradient Image<br/>
  <input id="optionShowClippedSobelLines" type="checkbox" checked="true"> Show Clipped Sobel Gradient Image with vectorized lines<br/>
 </fieldset>
</div>

<div id="labControlls">
	<input type="button" value="Apply Sobel Operator" onclick="handleTestClick();">
</div>

<div id="aboutControlls">
The perspective and scaling is derived from the vectorized inner contour of the black frame. The lines are vectorized with an 
antialiased search in the radon transformed gradient image (I always wanted to write this sentence:). Adjust the DPI of the output image to get more detail
but be aware that the resulting image might be huge.
<br/>
<br/>
Clifford's NumJS is used for solving the 8-dimensional linear equation that appears in the 
perspective matrix calculations...and thanks to clifford also for writing 
<a href="http://svn.clifford.at/handicraft/2011/cliprect/cliprect.cc">cliprect.cc</a>...my perspective correction code is just 
a 1:1 translation of clifford's code to js (so this makes this webpage GPL I guess:). Thanks to bernhard for showing me the radon transform in the context of line vectorization :)
<br/>
<br/>
The latest version of the full source code can be found here:
<a href="https://bitbucket.org/wizard23/surfaceaugmenter"https://bitbucket.org/wizard23/surfaceaugmenter</a>
<br/>
<br/>
I collect pictures of applications of the SurfaceAugmenter in <a href="http://www.flickr.com/photos/wizard23/sets/72157627506093695/">this flickr set.</a> 
<br/><br/>
(GPL) by <a href="http://www.wizards23.net/">wizard23</a>
</div>


<input type="file" value="imageFile" id="imageFile" />
	<input type="button" value="scale/1.2" onclick="scaleImage(1/1.2);">
	<input type="button" value="scale*1.2" onclick="scaleImage(1.2);">
<br/><br/>

</form>

<canvas id="canvas"></canvas>

<div id="dump">
Result Images will be created here.
</div>

<br/><br/>
(GPL) by <a href="http://www.wizards23.net/">wizard23</a>
</body>
</html>
