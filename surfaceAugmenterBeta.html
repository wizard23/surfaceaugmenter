<html>
<head>
<title>SurfaceAugmenter</title>
<style> </style>
<script type="text/javascript" src="libs/NumJS/NumJS.js"></script>
<script type="text/javascript">NumJS.loader_html("libs/NumJS/")</script>
<script type="text/javascript" src="src/image.js"></script>
<script type="text/javascript" src="src/helpers.js"></script>
<script type="text/javascript" src="src/lines.js"></script>
<script type="text/javascript">

var img;
var imgWidth, imgHeight;

var imgScale = 1.0;
var points = [];
var pixels, bwPixels, maskPixels;

var maskInitBlack = 50;
var maskLine = 200;
var maskOutBlack = 100;

function setup()
{
	changeMode('advanced');

	document.getElementById('imageFile').addEventListener('change', handleImageSelect, false);
	document.getElementById('canvas').addEventListener('click', handleCanvasClick, false);

	// enable dnd on canvas to load images
	var holder = document.getElementById('canvas');
	holder.ondragover = function () { this.className = 'hover'; return false; };
	holder.ondragend = function () { this.className = ''; return false; };
	holder.ondrop = function (e) {
		this.className = '';  // what for?
		e.preventDefault();
		var file = e.dataTransfer.files[0];
		asyncLoadImageFromFile(file);
	};


	asyncLoadImageFromURL("test2.jpg");
}

function handleImageSelect(evt) {
	pixels = undefined;
	var files = evt.target.files; // FileList object
	var file = files[0];
	asyncLoadImageFromFile(file);
}

function handleCanvasClick(evt) {
	var canvas = document.getElementById('canvas');
	var context = canvas.getContext('2d');

	clearDump();
	
	if (!pixels) {
		pixels = context.getImageData(0,0, canvas.width, canvas.height);
		//pixels2 = context.getImageData(0,0, canvas.width, canvas.height);
		bwPixels = RGBA2A(pixels, context);
		bwPixelsSobolev = createImageDataA(canvas.width, canvas.height);
		applyKernelAlphaOnPixels(bwPixels, dxx, dyy, bwPixelsSobolev);
		bwPixelsSobolevClipped = createImageDataA(canvas.width, canvas.height);
		maskPixels = createImageDataA(canvas.width, canvas.height);
		APixelsFill(maskPixels, 0);
	}

	var coords = canvas.relMouseCoords(evt);
	var x = coords.x/imgScale;
	var y = coords.y/imgScale;

	if (document.getElementById("radioSearchTypeManual").checked)
	{
		if (x >= 0 && x < imgWidth && y >= 0 && y < imgHeight)
			points.push({x:x, y:y});

		context.beginPath();
		context.arc(x, y, 3, 0, Math.PI*2, true); 
		context.closePath();
		context.fill();
	
		if (points.length == 4)
		{
			doCorrection(pixels, points, context, null);
			points = [];
		}
	}
	else {
		x = Math.round(x);
		y = Math.round(y);

		var whiteSum = 255;
		var whiteVarsum = 0;
		var whiteN = 1;
		var blackSum = 0;
		var blackVarsum = 0;
		var blackN = 1;


		var br = 0.0;
		fill4(x, y, function(x, y, state) {
			if (x >= 0 && x < imgWidth && y >= 0 && y < imgHeight)	{
				var whiteAvg = whiteSum/whiteN;
				var blackAvg = blackSum/blackN;
				var whiteVar = whiteVarsum/whiteN;
				var blackVar = blackVarsum/blackN;

				var idx = x+imgWidth*y;
				var idx4 = 4*idx;
				var mask = maskPixels.data[idx];
				
				if (mask == maskInitBlack || mask == maskLine || mask == maskOutBlack) {
					return false;
				}
				var val = bwPixelsSobolev.data[idx];

				br += 0.03;
				//pixels.data[idx4] = br;
				//pixels.data[idx4+1] = br-255;
				//pixels.data[idx4+2] = br-512;

				if (state == maskInitBlack)
				{
					if (val > (0.5*blackAvg+0.5*whiteAvg)) {
						//blackSum += val; blackVarsum += Math.abs(val-blackAvg); blackN++;
						whiteSum += val; whiteVarsum += Math.abs(val-whiteAvg); whiteN++;

						maskPixels.data[idx] = maskLine;
						return maskLine;
					}

					blackSum += val; blackVarsum += Math.abs(val-blackAvg); blackN++;
					//whiteSum += val; whiteVarsum += Math.abs(val-whiteAvg); whiteN++;
					maskPixels.data[idx] = maskInitBlack;

					return maskInitBlack;
				}
				else if (state == maskLine)
				{
					if (val < (0.7*blackAvg+0.3*whiteAvg)) {

						maskPixels.data[idx] = maskOutBlack;
						return maskOutBlack;
					}
					//blackSum += val; blackVarsum += Math.abs(val-blackAvg); blackN++;
					whiteSum += val; whiteVarsum += Math.abs(val-whiteAvg); whiteN++;

					maskPixels.data[idx] = maskLine;

					return maskLine;
				}
			}
			return false;
		}, maskInitBlack);


		applyMaskAlphaOnPixels(bwPixelsSobolev, maskPixels, bwPixelsSobolevClipped)

		var bestGroup = findLineCandidates(pixels, maskPixels, bwPixelsSobolevClipped);
		for (var i = 0; i < bestGroup.length; i++) {
			improveLine(bestGroup[i], bwPixelsSobolevClipped, 4, 0.05);
		}
		
		var pointsIn = [];
		for (var i = 0; i < bestGroup.length; i++) {
			pointsIn.push(intersectLines(bestGroup[i], bestGroup[(i+1)%bestGroup.length]));
		}

		
		doCorrection(pixels, pointsIn, context, bestGroup);
	}
}

function doCorrection(pixels, pointsIn, context, bestGroup) {
		if (bestGroup == null) {
			var bestGroup = [];
			for (var i = 0; i < pointsIn.length; i++) {		
				bestGroup.push({p1:pointsIn[i], p2:pointsIn[(i+1)%4]});
			}
		}
		
		// draw outher lines in pixels
		for (var i = 0; i < bestGroup.length; i++) {		
			drawLine2(bestGroup[i].p1, bestGroup[i].p2, pixels, 0, 255, 0);
		}

		drawLine2(pointsIn[0], pointsIn[2], pixels, 0, 0, 255);
		drawLine2(pointsIn[1], pointsIn[3], pixels, 0, 0, 255);

		var pixelsIn = pixels;

		var minD = -1, minIdx = -1;
		for (var i = 0; i < 4; i++) {
			var d = distancePoints({x:0,y:0}, pointsIn[i]);
		
			if (minIdx < 0 || d < minD) {
				minD = d;
				minIdx = i;
			}
		}
		//minIdx;
		var newPoints = [];
		for (var i = 0; i < 4; i++) {
			newPoints.push(pointsIn[(i+minIdx)%4]);
		}
		pointsIn = newPoints;
		

		var dpi = parseFloat(document.getElementById('outputDpi').value);
		var scale = dpi*0.0393700788; // 1mm = 0.0393700787 inch
		var markerWidth = parseFloat(document.getElementById("markerWidth").value);
		var markerHeight = parseFloat(document.getElementById("markerHeight").value);
		var outW = markerWidth*scale, outH = markerHeight*scale; // size of my testpattern 170x250mm
		var inputW = distancePoints(pointsIn[0], pointsIn[1]);
		var inputH = distancePoints(pointsIn[1], pointsIn[2])
		if ((inputW > inputH) != (outW > outH)) {
			var t = outW;
			outW = outH;
			outH = t;
		}
		var pointsOut = [{x:0, y:0}, {x:outW-1, y:0}, {x:outW-1, y:outH-1}, {x:0, y:outH-1}];
		//var pointsOut = [{x:0, y:0}, {x:outW, y:0}, {x:outW, y:outH}, {x:0, y:outH}];
		var params = calcParameters(pointsIn, pointsOut);
		//var params = calcParameters(pointsOut, pointsIn);

		var corners = [{x:0,y:0}, {x:pixelsIn.width-1, y:0}, {x:pixelsIn.width-1, y:pixelsIn.height-1}, {x:0, y:pixelsIn.height-1}];
		//var corners = [{x:0,y:0}, {x:pixelsIn.width, y:0}, {x:pixelsIn.width, y:pixelsIn.height}, {x:0, y:pixelsIn.height}];
		var minX = 100000, minY = 100000, maxX =-100000, maxY = -100000;
		for (var i = 0; i < 4; i++) {
			var cornerT = fwdMapXY(params, corners[i]);
			//var cornerT = invMapXY(params, corners[i]);
			//alert(cornerT.x + " " + cornerT.y);
			if (cornerT.x < minX) minX = cornerT.x;
			if (cornerT.x > maxX) maxX = cornerT.x;
			if (cornerT.y < minY) minY = cornerT.y;
			if (cornerT.y > maxY) maxY = cornerT.y;
		}

		if (document.getElementById("optionOutputNearest").checked) {
			var pixelsOut = context.createImageData(Math.ceil(maxX-minX), Math.ceil(maxY-minY));

			var idxOut = 0;
			for (var yOut = 0; yOut < pixelsOut.height; yOut++) {
				for (var xOut = 0; xOut < pixelsOut.width; xOut++) {
					var pointIn = invMapXY(params, {x:xOut+minX, y:yOut+minY})
					var xIn = Math.round(pointIn.x);
					var yIn = Math.round(pointIn.y);
					if (xIn >= 0 && yIn >= 0 && xIn < pixelsIn.width && yIn < pixelsIn.height) {
						var idxIn = 4*(yIn*pixelsIn.width+xIn);
			
						pixelsOut.data[idxOut] = pixelsIn.data[idxIn+0];
						pixelsOut.data[idxOut+1] = pixelsIn.data[idxIn+1];
						pixelsOut.data[idxOut+2] = pixelsIn.data[idxIn+2];
						pixelsOut.data[idxOut+3] = pixelsIn.data[idxIn+3];
					}
					idxOut += 4;
				}
			}
			dumpImageData(pixelsOut, "Perspective corrected image (Filter: None, Nearest Neighbour)");
		}		
		if (document.getElementById("optionOutputBilinear").checked) {
			var pixelsOut = context.createImageData(Math.ceil(maxX-minX), Math.ceil(maxY-minY));

			var idxOut = 0;
			for (var yOut = 0; yOut < pixelsOut.height; yOut++) {
				for (var xOut = 0; xOut < pixelsOut.width; xOut++) {
					var pointIn = invMapXY(params, {x:xOut+minX, y:yOut+minY})
					var xNextIdx, xNextScale, yNextIdx, yNextScale, xyNextIdx, xyNextScale;
				
					var xIn = Math.round(pointIn.x);
					var yIn = Math.round(pointIn.y);
				
					var idxIn = 4*(yIn*pixelsIn.width+xIn);
					if (xIn > pointIn.x) {
						xNextIdx = idxIn-4;
						xNextScale = xIn - pointIn.x;
					}
					else {
						xNextIdx = idxIn+4;
						xNextScale = pointIn.x - xIn;	
					}

					if (yIn > pointIn.y) {
						yNextIdx = idxIn-4*pixelsIn.width;
						yNextScale = yIn - pointIn.y;
						xyNextIdx = xNextIdx-4*pixelsIn.width;
					}
					else {
						yNextIdx = idxIn+4*pixelsIn.width;
						yNextScale = pointIn.y - yIn;
						xyNextIdx = xNextIdx+4*pixelsIn.width;
					}
				
					if (xIn >= 0 && yIn >= 0 && xIn < pixelsIn.width && yIn < pixelsIn.height) {
						var idxOut = 4*(yOut*pixelsOut.width+xOut);

						for (var i = 0; i < 3; i++) {
							pixelsOut.data[idxOut+i] = (1-yNextScale) * ((1 - xNextScale) * pixelsIn.data[idxIn+i] + 
							(xNextScale) * pixelsIn.data[xNextIdx+i]) + 
							(yNextScale) * ((1 - xNextScale) * pixelsIn.data[yNextIdx+i] + 
							(xNextScale) * pixelsIn.data[xyNextIdx+i]);
						}	
						pixelsOut.data[idxOut+3] = 255;				
					}
					idxOut += 4;
				}
			}
			dumpImageData(pixelsOut, "Perspective corrected image (Filter: Bilinear)");	
		}
		

		context.putImageData(pixels, 0,0);
	
		if (document.getElementById("optionShowSobel").checked) 
		{
			var grayPixels = A2RGBA(bwPixelsSobolev, context);
			dumpImageData(grayPixels, "magnitude of the sobel gradient");
		}
		if (document.getElementById("optionShowClippedSobel").checked) 
		{
			var grayPixels = A2RGBA(bwPixelsSobolevClipped, context);
			dumpImageData(grayPixels, "clipped magnitude of the sobel gradient");
		}
		if (document.getElementById("optionShowClippedSobelLines").checked) 
		{
			var grayPixels = A2RGBA(bwPixelsSobolevClipped, context);
			if (bestGroup != null) {
			for (var i = 0; i < bestGroup.length; i++) {		
				drawLine2(bestGroup[i].p1, bestGroup[i].p2, grayPixels, 255, 0, 0);
			}
			}
			dumpImageData(grayPixels, "clipped magnitude of the gradient overlayed with the vectorized lines (this is used for the search so the vectorized lines should be very well aligned with the pixels");
		}
		if (document.getElementById("optionShowMask").checked) {
			var grayPixels = A2RGBA(maskPixels, context);
			dumpImageData(grayPixels);
		}
}

  
function drawImage(img) {
	var canvas = document.getElementById('canvas');
	
	canvas.width = img.width;
	canvas.height = img.height;
	imgWidth = img.width;
	imgHeight = img.height;
	
	var context = canvas.getContext('2d');
	context.drawImage(img, 0, 0, img.width, img.height);
	
	
} 

function scaleImage(scale)
{
	imgScale *= scale;
	var canvas = document.getElementById('canvas');
	canvas.style.width = "" + (imgWidth*imgScale) +"px";
	canvas.style.height = "" + (imgHeight*imgScale) +"px";
	// 		
	//canvas.height = imgHeight;
}

var hist = {};
function handleTestClick()
{
	var canvas = document.getElementById('canvas');
	var context = canvas.getContext('2d');

	//var pixels = context.getImageData(110,110,120,120);
	var pixels = context.getImageData(0,0, canvas.width, canvas.height);

	var bwPixels = RGBA2A(pixels, context);
	var bwPixelsSobolev = RGBA2A(pixels, context);

	

	var x, y;

	applyKernelAlphaOnPixels(bwPixels, dxx, dyy, bwPixelsSobolev)

	var grayPixels = A2RGBA(bwPixelsSobolev, context);
	context.putImageData(grayPixels, 0,0);


	return;

	Pixastic.process(document.getElementById("canvas"), "histogram", {
		average : false, paint:true,color:"rgba(255,255,255,0.5)",returnValue:hist
	});
	document.getElementById('debugText').value = hist.values;
}


function xffdlj() {

	//pixels = context.getImageData(0,0, canvas.width, canvas.height);
	//bwPixels = Filters.RGBA2A(pixels, context);
	// applyKernelAlpha(pixels, kernel, x, y)
}

var allowedModes = ['auto', 'advanced', 'lab'];

function changeMode(mode) {
	for (var i = 0; i < allowedModes.length; i++) {
		var m = allowedModes[i];
		var id = m + "Controlls";
		if (m == mode) {
			//document.getElementById(id).style.visibility = "visible";
			document.getElementById(id).style.display = "block";
		}
		else {
			//document.getElementById(id).style.visibility = "hidden";
			document.getElementById(id).style.display = "none";
		}
	}
}

function clearDump() {
	removeAllChildrenFromNode(document.getElementById("dump"));
}

function dumpImageData(pixels, text) {

	var c = document.createElement('canvas');
	c.width = pixels.width;
	c.height = pixels.height;

	var div = document.createElement('div');
	div.innerText = text;
	document.getElementById("dump").appendChild(div);
	document.getElementById("dump").appendChild(c);

	var context = c.getContext('2d');	
	context.putImageData(pixels, 0,0);	
}

</script>

					
</head>
<body onload="setup()">
What do you want to do today? 
<a href="javascript:changeMode('auto');">Auto Perspective Correction</a> |
<a href="javascript:changeMode('advanced');">Advandced Perspective Correction</a> |
<a href="javascript:changeMode('lab');">Image Lab (Debug)</a> 
<br/><br/>
<form name="controls" action="">
	<input type="file" value="imageFile" id="imageFile" />
	<input type="button" value="scale/1.2" onclick="scaleImage(1/1.2);">
	<input type="button" value="scale*1.2" onclick="scaleImage(1.2);">
<br/><br/>

DPI of output image: <input type="text" id="outputDpi" value="25" /><br/>
<div id="autoControlls">
Click inside the inner white area of the marker to start the perspective correction.
</div>

<div id="advancedControlls">
Inner Width of Marker in mm: <input type="text" id="markerWidth" value="170" /><br/>
Inner Height of Marker in mm: <input type="text" id="markerHeight" value="250" /><br/>

<fieldset>
  <legend>How should the marker be found?</legend>
	<input id="radioSearchTypeAuto" type="radio" name="searchType" value="auto">Automatic marker detection: Click anywhere in the image to start the perspective correction<br>
	<input id="radioSearchTypeClickCenter" type="radio" name="searchType" value="click" checked="true">Click inside the inner white area of the marker to start the perspective correction<br>
	<input id="radioSearchTypeManual" type="radio" name="searchType" value="manual">Manually click onto the 4 corners in clockwise order to start the perspective correction<br>
</fieldset>

<fieldset>
  <legend>How should the perspective correction be done? (Multiple output paths can be selected for comparison)</legend>
  <input id="optionOutputNearest" type="checkbox" checked="true">Javascript/Canvas using No Filter/Nearest Neighbour<br/>
  <input id="optionOutputBilinear" type="checkbox" checked="true">Javascript/Canvas using Bilinear Interpolation<br/>
  <input id="radioOutputTypeImageMagick" type="checkbox" checked="true">ImageMagick command line (recommended for larger DPI)<br>
</fieldset>

<fieldset>
  <legend>How does it work? Show me the guts!</legend>
  <input id="optionShowSobel" type="checkbox" checked="true"> Show Sobel Gradient Image<br/>
  <input id="optionShowClippedSobel" type="checkbox" checked="true"> Show Clipped Gradient Image<br/>
  <input id="optionShowClippedSobelLines" type="checkbox" checked="true"> Show Clipped Sobel Gradient Image with vectorized lines<br/>
  <input id="optionShowMask" type="checkbox" checked="true"> Show Mask Image<br/>
 </fieldset>
</div>

<div id="labControlls">
	<input type="button" value="Apply Sobel Operator" onclick="handleTestClick();">
</div>

</form>

<canvas id="canvas"></canvas>

<div id="dump">
Result Images will be created here.
</div>

<br/><br/>
(GPL) by <a href="http://www.wizards23.net/">wizard23</a>
<br/><br/>
thanks for scrolling down this far!
</body>
</html>
