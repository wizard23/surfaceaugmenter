<html>
<head>
<title>SurfaceAugmenter</title>
<style> </style>
<script type="text/javascript" src="libs/NumJS/NumJS.js"></script>
<script type="text/javascript">NumJS.loader_html("libs/NumJS/")</script>

<script type="text/javascript" src="src/image.js"></script>
<script type="text/javascript" src="src/helpers.js"></script>
<script type="text/javascript" src="src/lines.js"></script>
<script type="text/javascript" src="libs/pixastic/pixastic.core.js"></script>
<script type="text/javascript" src="libs/pixastic/actions/histogram.js"></script>
<script type="text/javascript">


var img;
var imgWidth, imgHeight;

var imgScale = 1.0;
var points = [];
var pixels, bwPixels, maskPixels;

var maskInitBlack = 50;
var maskLine = 200;
var maskOutBlack = 100;

function setup()
{
	changeMode('advanced');

	document.getElementById('imageFile').addEventListener('change', handleImageSelect, false);
	document.getElementById('canvas').addEventListener('click', handleCanvasClick, false);

	// enable dnd on canvas to load images
	var holder = document.getElementById('canvas');
	holder.ondragover = function () { this.className = 'hover'; return false; };
	holder.ondragend = function () { this.className = ''; return false; };
	holder.ondrop = function (e) {
		this.className = '';  // what for?
		e.preventDefault();
		var file = e.dataTransfer.files[0];
		asyncLoadImageFromFile(file);
	};


	asyncLoadImageFromURL("test2.jpg");
}

function handleImageSelect(evt) {
	pixels = undefined;
	var files = evt.target.files; // FileList object
	var file = files[0];
	asyncLoadImageFromFile(file);
}

function handleCanvasClick(evt) {
	var canvas = document.getElementById('canvas');
	var context = canvas.getContext('2d');
	
	if (!pixels) {
		pixels = context.getImageData(0,0, canvas.width, canvas.height);
		//pixels2 = context.getImageData(0,0, canvas.width, canvas.height);
		bwPixels = RGBA2A(pixels, context);
		bwPixelsSobolev = createImageDataA(canvas.width, canvas.height);
		applyKernelAlphaOnPixels(bwPixels, dxx, dyy, bwPixelsSobolev);
		maskPixels = createImageDataA(canvas.width, canvas.height);
		APixelsFill(maskPixels, 0);
	}

	var coords = canvas.relMouseCoords(evt);
	var x = coords.x/imgScale;
	var y = coords.y/imgScale;

	if (true || evt.ctrlKey || evt.button == 1)
	{
		x = Math.round(x);
		y = Math.round(y);

		var whiteSum = 255;
		var whiteVarsum = 0;
		var whiteN = 1;
		var blackSum = 0;
		var blackVarsum = 0;
		var blackN = 1;


		var br = 0.0;
		fill4(x, y, function(x, y, state) {
			if (x >= 0 && x < imgWidth && y >= 0 && y < imgHeight)	{
				var whiteAvg = whiteSum/whiteN;
				var blackAvg = blackSum/blackN;
				var whiteVar = whiteVarsum/whiteN;
				var blackVar = blackVarsum/blackN;


				var idx = x+imgWidth*y;
				var idx4 = 4*idx;
				var mask = maskPixels.data[idx];
				
				if (mask == maskInitBlack || mask == maskLine || mask == maskOutBlack) {
					return false;
				}
				var val = bwPixelsSobolev.data[idx];

				br += 0.03;
				//pixels.data[idx4] = br;
				//pixels.data[idx4+1] = br-255;
				//pixels.data[idx4+2] = br-512;

				if (state == maskInitBlack)
				{
					if (val > (0.5*blackAvg+0.5*whiteAvg)) {
						//blackSum += val; blackVarsum += Math.abs(val-blackAvg); blackN++;
						whiteSum += val; whiteVarsum += Math.abs(val-whiteAvg); whiteN++;

						maskPixels.data[idx] = maskLine;
						return maskLine;
					}

					blackSum += val; blackVarsum += Math.abs(val-blackAvg); blackN++;
					//whiteSum += val; whiteVarsum += Math.abs(val-whiteAvg); whiteN++;
					maskPixels.data[idx] = maskInitBlack;

					return maskInitBlack;
				}
				else if (state == maskLine)
				{
					if (val < (0.7*blackAvg+0.3*whiteAvg)) {

						maskPixels.data[idx] = maskOutBlack;
						return maskOutBlack;
					}
					//blackSum += val; blackVarsum += Math.abs(val-blackAvg); blackN++;
					whiteSum += val; whiteVarsum += Math.abs(val-whiteAvg); whiteN++;

					maskPixels.data[idx] = maskLine;

					return maskLine;
				}
			}
			return false;
		}, maskInitBlack);


		applyMaskAlphaOnPixels(bwPixelsSobolev, maskPixels, bwPixelsSobolev)

		var bestGroup = findLineCandidates(pixels, maskPixels, bwPixelsSobolev);
		for (var i = 0; i < bestGroup.length; i++) {
			improveLine(bestGroup[i], bwPixelsSobolev, 4, 0.05);
		}
		for (var i = 0; i < bestGroup.length-2; i++) {
			var x1 = intersectLines(bestGroup[i], bestGroup[i+1]);
			var x2 = intersectLines(bestGroup[i+2], bestGroup[(i+3)%bestGroup.length]);
			drawLine2(x1, x2, pixels, 0, 0, 255);
		}



		var pixelsIn = pixels;

		var pointsIn = [];
		for (var i = 0; i < bestGroup.length; i++) {
			pointsIn.push(intersectLines(bestGroup[i], bestGroup[(i+1)%bestGroup.length]));
		}

		var minD = -1, minIdx = -1;
		for (var i = 0; i < 4; i++) {
			var d = distancePoints({x:0,y:0}, pointsIn[i]);
		
			if (minIdx < 0 || d < minD) {
				minD = d;
				minIdx = i;
			}
		}
		//minIdx;
		var newPoints = [];
		for (var i = 0; i < 4; i++) {
			newPoints.push(pointsIn[(i+minIdx)%4]);
		}
		pointsIn = newPoints;
		

		var dpi = parseFloat(document.getElementById('outputDpi').value);
		var scale = dpi*0.0393700788; // 1mm = 0.0393700787 inch
		var markerWidth = parseFloat(document.getElementById("markerWidth").value);
		var markerHeight = parseFloat(document.getElementById("markerHeight").value);
		var outW = markerWidth*scale, outH = markerHeight*scale; // size of my testpattern 170x250mm
		var inputW = distancePoints(pointsIn[0], pointsIn[1]);
		var inputH = distancePoints(pointsIn[1], pointsIn[2])
		if ((inputW > inputH) != (outW > outH)) {
			var t = outW;
			outW = outH;
			outH = t;
		}
		var pointsOut = [{x:0, y:0}, {x:outW-1, y:0}, {x:outW-1, y:outH-1}, {x:0, y:outH-1}];
		//var pointsOut = [{x:0, y:0}, {x:outW, y:0}, {x:outW, y:outH}, {x:0, y:outH}];
		var params = calcParameters(pointsIn, pointsOut);
		//var params = calcParameters(pointsOut, pointsIn);

		var corners = [{x:0,y:0}, {x:pixelsIn.width-1, y:0}, {x:pixelsIn.width-1, y:pixelsIn.height-1}, {x:0, y:pixelsIn.height-1}];
		//var corners = [{x:0,y:0}, {x:pixelsIn.width, y:0}, {x:pixelsIn.width, y:pixelsIn.height}, {x:0, y:pixelsIn.height}];
		var minX = 100000, minY = 100000, maxX =-100000, maxY = -100000;
		for (var i = 0; i < 4; i++) {
			var cornerT = fwdMapXY(params, corners[i]);
			//var cornerT = invMapXY(params, corners[i]);
			//alert(cornerT.x + " " + cornerT.y);
			if (cornerT.x < minX) minX = cornerT.x;
			if (cornerT.x > maxX) maxX = cornerT.x;
			if (cornerT.y < minY) minY = cornerT.y;
			if (cornerT.y > maxY) maxY = cornerT.y;
		}
		var pixelsOutAliased = context.createImageData(Math.ceil(maxX-minX), Math.ceil(maxY-minY));
		var pixelsOut = context.createImageData(Math.ceil(maxX-minX), Math.ceil(maxY-minY));
		


		for (var yOut = 0; yOut < pixelsOut.height; yOut++) {
			for (var xOut = 0; xOut < pixelsOut.width; xOut++) {
				//var pointIn = fwdMapXY(params, {x:xOut+minX, y:yOut+minY})
				var pointIn = invMapXY(params, {x:xOut+minX, y:yOut+minY})
				//pointIn.x -= minX;
				//pointIn.y -= minY;
				var xNextIdx, xNextScale, yNextIdx, yNextScale, xyNextIdx, xyNextScale;
				
				var xIn = Math.round(pointIn.x);
				var yIn = Math.round(pointIn.y);
				
				var idxIn = 4*(yIn*pixelsIn.width+xIn);
				if (xIn > pointIn.x) {
					xNextIdx = idxIn-4;
					xNextScale = xIn - pointIn.x;
				}
				else {
					xNextIdx = idxIn+4;
					xNextScale = pointIn.x - xIn;	
				}

				if (yIn > pointIn.y) {
					yNextIdx = idxIn-4*pixelsIn.width;
					yNextScale = yIn - pointIn.y;
					
					xyNextIdx = xNextIdx-4*pixelsIn.width;
					//xyNextIdx = 0;
				}
				else {
					yNextIdx = idxIn+4*pixelsIn.width;
					yNextScale = pointIn.y - yIn;

					xyNextIdx = xNextIdx+4*pixelsIn.width;
					//xyNextIdx = 0;
				}
				
				
				if (xIn >= 0 && yIn >= 0 && xIn < pixelsIn.width && yIn < pixelsIn.height) {
					var idxIn = 4*(yIn*pixelsIn.width+xIn);
					var idxOut = 4*(yOut*pixelsOut.width+xOut);

					for (var i = 0; i < 4; i++) {
						//pixelsOutAliased.data[idxOut+i] = 
						//		        (1 - xNextScale) * (1 - yNextScale) * pixelsIn.data[idxIn+i] + 
						//			(1 - xNextScale) * (yNextScale) * pixelsIn.data[yNextIdx+i] +
						//			(xNextScale) * (1 - yNextScale) * pixelsIn.data[xNextIdx+i] +
						//			(xNextScale) * (yNextScale) * pixelsIn.data[xyNextIdx+i];
						



						pixelsOutAliased.data[idxOut+i] =
	(1-yNextScale) * ((1 - xNextScale) * pixelsIn.data[idxIn+i] + (xNextScale) * pixelsIn.data[xNextIdx+i]) +
	(yNextScale) * ((1 - xNextScale) * pixelsIn.data[yNextIdx+i] + (xNextScale) * pixelsIn.data[xyNextIdx+i]);
	

						pixelsOut.data[idxOut+i] = pixelsIn.data[idxIn+i];
					}					
					//pixelsOut.data[idxOut+1] = pixelsIn.data[idxIn+1];
					//pixelsOut.data[idxOut+2] = pixelsIn.data[idxIn+2];
					//pixelsOut.data[idxOut+3] = pixelsIn.data[idxIn+3];
				}
				//else alert(xIn + " " + xOut);
			}
		}




		for (var i = 0; i < bestGroup.length; i++) {		
			drawLine2(bestGroup[i].p1, bestGroup[i].p2, pixels, 0, 255, 0);
			drawLine2A(bestGroup[i].p1, bestGroup[i].p2, bwPixelsSobolev, 0);
		}


		context.putImageData(pixels, 0,0);
		
		var canvasResultAliased = document.getElementById('canvasResultAliased');
		canvasResultAliased.width = pixelsOutAliased.width;
		canvasResultAliased.height = pixelsOutAliased.height;
		var contextResultAliased = canvasResultAliased.getContext('2d');	
		contextResultAliased.putImageData(pixelsOutAliased, 0,0);
	
		var grayPixels = A2RGBA(bwPixelsSobolev, context);
		for (var i = 0; i < bestGroup.length; i++) {		
			drawLine2(bestGroup[i].p1, bestGroup[i].p2, grayPixels, 255, 0, 0);
		}
		
		
		dumpImageData(grayPixels);

		/*
		var canvasResult = document.getElementById('canvasResult');
		canvasResult.width = pixelsOut.width;
		canvasResult.height = pixelsOut.height;
		var contextResult = canvasResult.getContext('2d');	
		contextResult.putImageData(pixelsOut, 0,0);	
		
		var canvas2 = document.getElementById('canvas2');
		canvas2.width = maskPixels.width;
		canvas2.height = maskPixels.height;
		var context2 = canvas2.getContext('2d');	
		var grayPixels = A2RGBA(maskPixels, context2);
		context2.putImageData(grayPixels, 0,0);	
	
		var canvas3 = document.getElementById('canvas3');
		canvas3.width = maskPixels.width;
		canvas3.height = maskPixels.height;
		var context3 = canvas3.getContext('2d');	
		var grayPixels = A2RGBA(bwPixelsSobolev, context3);
		for (var i = 0; i < bestGroup.length; i++) {		
			drawLine2(bestGroup[i].p1, bestGroup[i].p2, grayPixels, 255, 0, 0);
		}
		context3.putImageData(grayPixels, 0,0);	
		*/	

		


	}
	else {
		if (x >= 0 && x < imgWidth && y >= 0 && y < imgHeight)
			points.push([x, y]);

		context.beginPath();
		context.arc(x, y, 3, 0, Math.PI*2, true); 
		context.closePath();
		context.fill();
	
		if (points.length == 2)
		{
			var sum = 0;
			var n = 0;
			var w = bwPixels.width;

			xiaolinWuLineIterator(points[0][0],points[0][1], points[1][0], points[1][1], function(x, y, c) { 
				n += c; 
				sum += c* bwPixels.data[x+w*y];
				pixels.data[4*(x+w*y)] = (1-c) * pixels.data[4*(x+w*y)] + c * 0;
				pixels.data[4*(x+w*y)+1] = (1-c) * pixels.data[4*(x+w*y)+1] + c * 0;
				pixels.data[4*(x+w*y)+2] = (1-c) * pixels.data[4*(x+w*y)+2] + c * 0;
				//pixels.data[4*(x+w*y)+3] = 255;
			});
			alert("s: " + sum + " n: " + n + " avg: " + (sum/n));

			/*
			lineIterator(points[0][0],points[0][1], points[1][0], points[1][1], function(x, y) { 
				n++; 
				sum += bwPixels[x+w*y];
				pixels.data[4*(x+w*y)] = 255 - pixels.data[4*(x+w*y)];
				pixels.data[4*(x+w*y)+1] = 255 - pixels.data[4*(x+w*y)+1];canvas.width = img.width;
	canvas.height = img.height;
				pixels.data[4*(x+w*y)+2] = 255 - pixels.data[4*(x+w*y)+2];
			});
			//*/
			//alert("s: " + sum + " n: " + n + " " + (sum/n));

			context.putImageData(pixels, 0, 0);
		
			//document.getElementById('outputText').value = "convert ..\\..\\web\\" + fileName + " -virtual-pixel transparent -distort Perspective \"" + s + "\" " + fileName + "out.png";
			//handleLoad(img);
			points = [];
		}
	}
}
  
function drawImage(img) {
	var canvas = document.getElementById('canvas');
	
	canvas.width = img.width;
	canvas.height = img.height;
	imgWidth = img.width;
	imgHeight = img.height;
	
	var context = canvas.getContext('2d');
	context.drawImage(img, 0, 0, img.width, img.height);
	
	
} 

function scaleImage(scale)
{
	imgScale *= scale;
	var canvas = document.getElementById('canvas');
	canvas.style.width = "" + (imgWidth*imgScale) +"px";
	canvas.style.height = "" + (imgHeight*imgScale) +"px";
	// 		
	//canvas.height = imgHeight;
}

var hist = {};
function handleTestClick()
{
	var canvas = document.getElementById('canvas');
	var context = canvas.getContext('2d');

	//var pixels = context.getImageData(110,110,120,120);
	var pixels = context.getImageData(0,0, canvas.width, canvas.height);

	var bwPixels = RGBA2A(pixels, context);
	var bwPixelsSobolev = RGBA2A(pixels, context);

	

	var x, y;

	applyKernelAlphaOnPixels(bwPixels, dxx, dyy, bwPixelsSobolev)

	var grayPixels = A2RGBA(bwPixelsSobolev, context);
	context.putImageData(grayPixels, 0,0);


	return;

	Pixastic.process(document.getElementById("canvas"), "histogram", {
		average : false, paint:true,color:"rgba(255,255,255,0.5)",returnValue:hist
	});
	document.getElementById('debugText').value = hist.values;
}


function xffdlj() {

	//pixels = context.getImageData(0,0, canvas.width, canvas.height);
	//bwPixels = Filters.RGBA2A(pixels, context);
	// applyKernelAlpha(pixels, kernel, x, y)
}

var allowedModes = ['auto', 'advanced', 'lab'];

function changeMode(mode) {
	for (var i = 0; i < allowedModes.length; i++) {
		var m = allowedModes[i];
		var id = m + "Controlls";
		if (m == mode) {
			//document.getElementById(id).style.visibility = "visible";
			document.getElementById(id).style.display = "block";
		}
		else {
			//document.getElementById(id).style.visibility = "hidden";
			document.getElementById(id).style.display = "none";
		}
	}
}

function dumpImageData(pixels) {

	var c = document.createElement('canvas');
	c.width = pixels.width;
	c.height = pixels.height;
	document.getElementById("dump").appendChild(c);

	var context = c.getContext('2d');	
	context.putImageData(pixels, 0,0);	
}

</script>

					
</head>
<body onload="setup()">
What do you want to do today? 
<a href="javascript:changeMode('auto');">Auto Perspective Correction</a> |
<a href="javascript:changeMode('advanced');">Advandced Perspective Correction</a> |
<a href="javascript:changeMode('lab');">Image Lab (Debug)</a> 
<br/><br/>
<form name="controls" action="">
	<input type="file" value="imageFile" id="imageFile" />
	<input type="button" value="scale/1.2" onclick="scaleImage(1/1.2);">
	<input type="button" value="scale*1.2" onclick="scaleImage(1.2);">
<br/><br/>

DPI of output image: <input type="text" id="outputDpi" value="25" /><br/>
<div id="autoControlls">
Click inside the inner white area of the marker to start the perspective correction.
</div>

<div id="advancedControlls">
Inner Width of Marker in mm: <input type="text" id="markerWidth" value="170" /><br/>
Inner Height of Marker in mm: <input type="text" id="markerHeight" value="250" /><br/>

<fieldset>
  <legend>How should the marker be found?</legend>
	<input id="radioSearchTypeAuto" type="radio" name="searchType" value="auto">Automatic marker detection: Click anywhere in the image to start the perspective correction<br>
	<input id="radioSearchTypeClickCenter" type="radio" name="searchType" value="click" checked="true">Click inside the inner white area of the marker to start the perspective correction<br>
	<input id="radioSearchTypeManual" type="radio" name="searchType" value="manual">Manually click onto the 4 corners in clockwise order to start the perspective correction<br>
</fieldset>

<fieldset>
  <legend>How should the perspective correction be done?</legend>
	<input id="radioOutputTypeCanvas" type="radio" name="outputType" value="canvas" checked="true">in the browser using js/canvas (slow when using high DPI!)<br>
	<input id="radioOutputTypeImageMagick" type="radio" name="outputType" value="imageMagick">ImageMagick command line (recommended for larger DPI)<br>
</fieldset>
<fieldset>
  <legend>Options</legend>
  <input type=checkbox checked="true"> Use Bilinear Interpolation<br/>
  <input type=checkbox> Show Gradient Image<br/>
  <input type=checkbox> Show Mask Image<br/>
  <input type=checkbox> Show Clipped Gradient Image<br/>
  <input type=checkbox> Show Clipped Gradient Image with vectorized lines<br/>
 </fieldset>
</div>

<div id="labControlls">
	<input type="button" value="Apply Sobel Operator" onclick="handleTestClick();">
</div>

</form>

<canvas id="canvas"></canvas>


<div id="dump">
Image Dump
</div>

<br>
<br>
the perspective and size corrected image antialiased
<br>
<canvas id="canvasResultAliased"></canvas>
<br>
<br>
the perspective and size corrected image non-antialiased
<br>
<canvas id="canvasResult"></canvas>
<br>
<br>
the mask used for clipping the gradient for the line search
<br>
<canvas id="canvas2"></canvas>
<br>
<br>
the clipped magnitude of the gradient overlayed with the vectorized lines (this is used for the search so the vectorized lines should be very well aligned with the pixels)
<br>
<canvas id="canvas3"></canvas>
<br/><br/>
Next steps: Antialiased corrected image and saving the output as png or jpg, whitebalance, handling of raw files (mad laughter!!!11elf)...js is so cool :) 
<br/><br/>
(GPL) by <a href="http://www.wizards23.net/">wizard23</a>
<br/><br/>
thanks for scrolling down this far!
</body>
</html>
